#!/usr/bin/python

# Inspired by https://community.home-assistant.io/t/linux-gnome-retreive-the-lock-or-unlock-state-of-your-linux-computer/181489/4
import logging
import dbus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib
import random
import paho.mqtt.publish as mqtt

# For Watchdog timestamp
from datetime import datetime

# For payload formatting
import json

# For IP checks
import socket
import fcntl
import struct

# For current user (and thus topic)
import os
import pwd

# For config
import configparser

username = os.getlogin()
fullname = pwd.getpwuid(os.geteuid()).pw_gecos

config = configparser.ConfigParser()
config.read(os.path.expanduser('~/.config/mqtt-status-updater.conf'))

mqtt_host = config.get('mqtt', 'host', fallback='localhost')
mqtt_port = int(config.get('mqtt', 'port', fallback='1883'))
mqtt_auth = {
  'username': config.get('mqtt', 'username', fallback=''),
  'password': config.get('mqtt', 'password', fallback='')
}

lan_interface = config.get('lan', 'interface', fallback='')

mqtt_topic = config.get('mqtt', 'topic', fallback='mqtt_status_updater/' + username)

ha_autodiscovery_sent = False

state = {'lastseen': 0, 'locked': True, 'lan': False}

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("MQTT_Desktop_Status")

def exit_gracefully(signum=0, frame=None):
    logger.info('Exiting now')
    loop.quit()
    update_mqtt_locked_state(True, False)
    exit(0)
   
def update_mqtt():
    global ha_autodiscovery_sent

    if not ha_autodiscovery_sent:
        try:
            ha_base_topic = config.get('homeassistant', 'basetopic', fallback='homeassistant')
            ha_unique_id = config.get('homeassistant', 'uniqueid', fallback='mqtt_status_updater_' + username)
            ha_device_name = config.get('homeassistant', 'devicename', fallback=fullname + "'s Computer")

            ha_autodiscovery_topic = ha_base_topic + '/sensor/' + ha_unique_id + '/config'
            ha_autodiscovery_data = {
                "name": 'At Desk',
                "state_topic": mqtt_topic,
                "value_template": "{{ iif( ( ( ( as_timestamp( utcnow() ) - value_json.lastseen ) < 30 ) and ( value_json.lan ) and ( not value_json.locked ) ), 'Yes', 'No' ) }}",
                "unique_id": ha_unique_id,
                "device": {
                    "name": ha_device_name,
                    "identifiers": [
                        ha_unique_id
                    ]
                }
            }
            mqtt.single(ha_autodiscovery_topic, json.dumps(ha_autodiscovery_data), hostname=mqtt_host, port=mqtt_port, auth=mqtt_auth)
            ha_autodiscovery_sent = True
            logger.info(f"Sent HA Autodiscovery Data")
        except:
            logger.info(f"Cannot send HA Autodiscovery Data")
            pass

    try:
        msg = json.dumps(state)
        mqtt.single(mqtt_topic, msg, hostname=mqtt_host, port=mqtt_port, auth=mqtt_auth)
        logger.info(f"Send `{msg}` to topic `{mqtt_topic}`")
    except:
        logger.info(f"Failed to send message to topic {mqtt_topic}")
        pass

# From https://stackoverflow.com/a/1947766
def get_interface_ip(ifname):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return socket.inet_ntoa(fcntl.ioctl(
                s.fileno(),
                0x8915,  # SIOCGIFADDR
                struct.pack('256s', bytes(ifname[:15], 'utf-8'))
                # Python 2.7: remove the second argument for the bytes call
            )[20:24])
    except:
        pass
    return None

def watchdog():
    global state
    state['lastseen'] = datetime.now().timestamp()
    if lan_interface:
        state['lan'] = bool(get_interface_ip(lan_interface))
    update_mqtt()
    return True

def set_dbus_loop():
    DBusGMainLoop(set_as_default=True)
    session_bus = dbus.SessionBus()
    session_bus.add_signal_receiver(update_mqtt_locked_state,
                                    dbus_interface="org.gnome.ScreenSaver",
                                    signal_name="ActiveChanged")
    loop = GLib.MainLoop()
    GLib.timeout_add(5000, watchdog)
    return loop

def update_mqtt_locked_state(is_locked, log = True):
    global state
    state['locked'] = bool(is_locked)
    if log:
        msg = 'The computer is now unlocked'
        if is_locked:
            msg = 'The computer is now locked'
        logger.info(msg)
    watchdog()    

if __name__ == '__main__':
    try:
        update_mqtt_locked_state(False, False)
        loop = set_dbus_loop()
        loop.run()
    except KeyboardInterrupt:
        exit_gracefully()

