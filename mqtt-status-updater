#!/usr/bin/python

# Inspired by https://community.home-assistant.io/t/linux-gnome-retreive-the-lock-or-unlock-state-of-your-linux-computer/181489/4
import logging
import dbus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib
import random
import paho.mqtt.publish as mqtt

# For Watchdog timestamp
from datetime import datetime

# For payload formatting
import json

# For IP checks
import socket
import fcntl
import struct

# For current user (and thus topic)
import os
import pwd

username = os.getlogin()
fullname = pwd.getpwuid(os.geteuid()).pw_gecos

LAN_INTERFACE = ""
MQTT_BROKER = ""
MQTT_USERNAME = ""
MQTT_PASSWORD = ""

MQTT_PORT = 1883
MQTT_BASE_TOPIC = "gnome/" + username
MQTT_CLIENT_ID = f'python-mqtt-{random.randint(0, 1000)}'


state = {'lastseen': 0, 'locked': True, 'lan': False}

ha_autodiscovery_sent = False

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("MQTT_Desktop_Status")

def exit_gracefully(signum=0, frame=None):
    logger.info('Exiting now')
    loop.quit()
    update_mqtt_locked_state(True, False)
    exit(0)
   
def update_mqtt():
    global state, ha_autodiscovery_sent

    if not ha_autodiscovery_sent:
        try:
            ha_autodiscovery_topic = 'homeassistant/sensor/gnome_' + username + '/config'
            ha_autodiscovery_data = {
                "name": 'At Desk',
                "state_topic": MQTT_BASE_TOPIC,
                "value_template": "{{ iif( ( ( ( as_timestamp( utcnow() ) - value_json.lastseen ) < 30 ) and ( value_json.lan ) and ( not value_json.locked ) ), 'Yes', 'No' ) }}",
                "unique_id": 'gnome_' + username,
                "device": {
                    "name": fullname + "'s Computer",
                    "identifiers": [
                        'gnome_' + username
                    ]
                }
            }
            mqtt.single(ha_autodiscovery_topic, json.dumps(ha_autodiscovery_data), hostname=MQTT_BROKER, auth={'username':MQTT_USERNAME,'password':MQTT_PASSWORD})
            ha_autodiscovery_sent = True
            logger.info(f"Sent HA Autodiscovery Data")
        except:
            logger.info(f"Cannot send HA Autodiscovery Data")
            pass

    topic = MQTT_BASE_TOPIC
    msg = json.dumps(state)
    try:
        mqtt.single(topic, msg, hostname=MQTT_BROKER, auth={'username':MQTT_USERNAME,'password':MQTT_PASSWORD})
        logger.info(f"Send `{msg}` to topic `{topic}`")
    except:
        logger.info(f"Failed to send message to topic {topic}")
        pass

# From https://stackoverflow.com/a/1947766
def get_interface_ip(ifname):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return socket.inet_ntoa(fcntl.ioctl(
                s.fileno(),
                0x8915,  # SIOCGIFADDR
                struct.pack('256s', bytes(ifname[:15], 'utf-8'))
                # Python 2.7: remove the second argument for the bytes call
            )[20:24])
    except:
        pass
    return None

def watchdog():
    global state
    state['lastseen'] = datetime.now().timestamp()
    if LAN_INTERFACE:
        state['lan'] = bool(get_interface_ip(LAN_INTERFACE))
    update_mqtt()
    return True

def set_dbus_loop():
    DBusGMainLoop(set_as_default=True)
    session_bus = dbus.SessionBus()
    session_bus.add_signal_receiver(update_mqtt_locked_state,
                                    dbus_interface="org.gnome.ScreenSaver",
                                    signal_name="ActiveChanged")
    loop = GLib.MainLoop()
    GLib.timeout_add(5000, watchdog)
    return loop

def update_mqtt_locked_state(is_locked, log = True):
    global state
    state['locked'] = bool(is_locked)
    if log:
        msg = 'The computer is now unlocked'
        if is_locked:
            msg = 'The computer is now locked'
        logger.info(msg)
    watchdog()    

if __name__ == '__main__':
    try:
        update_mqtt_locked_state(False, False)
        loop = set_dbus_loop()
        loop.run()
    except KeyboardInterrupt:
        exit_gracefully()

